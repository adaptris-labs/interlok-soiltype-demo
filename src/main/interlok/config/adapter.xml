<adapter
  xmlns:xi="http://www.w3.org/2001/XInclude">
  <unique-id>${adapter.unique.id}</unique-id>
  <shared-components>
    <connections>
      <cache-connection>
        <unique-id>soil-type-cache</unique-id>
        <cache-instance class="default-ehcache">
          <cache-name>SoilTypeCache</cache-name>
          <eviction-policy>LRU</eviction-policy>
          <max-elements-in-memory>10</max-elements-in-memory>
        </cache-instance>
      </cache-connection>
      <jetty-embedded-connection>
        <unique-id>jetty-connection</unique-id>
      </jetty-embedded-connection>
    </connections>
  </shared-components>
  <heartbeat-event-interval>
    <unit>MINUTES</unit>
    <interval>60</interval>
  </heartbeat-event-interval>
  <message-error-handler class="standard-processing-exception-handler">
    <processing-exception-service class="service-list">
      <services>
        <exception-report-service>
          <exception-serializer class="exception-as-json-with-stacktrace"/>
        </exception-report-service>
        <standalone-producer>
          <producer class="jetty-standard-response-producer">
            <status-provider class="http-configured-status">
              <status>INTERNAL_ERROR_500</status>
            </status-provider>
            <content-type-provider class="http-configured-content-type-provider">
              <mime-type>application/json</mime-type>
            </content-type-provider>
            <send-payload>true</send-payload>
          </producer>
        </standalone-producer>
      </services>
    </processing-exception-service>
  </message-error-handler>
  <channel-list>
    <channel>
      <auto-start>true</auto-start>
      <unique-id>SoilData</unique-id>
      <consume-connection class="shared-connection">
        <lookup-name>jetty-connection</lookup-name>
      </consume-connection>
      <workflow-list>
        <standard-workflow>
          <unique-id>Swagger</unique-id>
          <send-events>false</send-events>
          <consumer class="jetty-message-consumer">
            <unique-id>/lookups/swagger</unique-id>
            <destination class="configured-consume-destination">
              <configured-thread-name>Swagger</configured-thread-name>
              <filter-expression>GET</filter-expression>
              <destination>/lookups/swagger/*</destination>
            </destination>
            <parameter-handler class="jetty-http-parameters-as-metadata"/>
            <header-handler class="jetty-http-ignore-headers"/>
          </consumer>
          <service-collection class="service-list">
            <services>
              <aggregating-fs-consume-service>
                <fs-consumer>
                  <destination class="consume-destination-from-metadata">
                    <default-destination>${swagger.yaml.file}</default-destination>
                  </destination>
                  <delete-aggregated-files>false</delete-aggregated-files>
                  <message-aggregator class="replace-with-first-message-aggregator"/>
                </fs-consumer>
              </aggregating-fs-consume-service>
              <yaml-to-json>
                <source class="string-payload-data-input-parameter"/>
                <target class="string-payload-data-output-parameter"/>
              </yaml-to-json>
              <!-- rewrite the swagger so it has the correct hostname -->
              <json-transform-service>
                <source-json class="string-payload-data-input-parameter"/>
                <target-json class="string-payload-data-output-parameter"/>
                <mapping-spec class="constant-data-input-parameter">
                  <value>[{ "operation": "remove", "spec": {"host": "" }},{"operation": "shift", "spec": { "*": "&amp;","#${adapter.api.hostname}": "host"}}]</value>
                </mapping-spec>
                <metadata-filter class="regex-metadata-filter"/>
              </json-transform-service>
              <standalone-producer>
                <unique-id>SendResponse</unique-id>
                <producer class="jetty-standard-response-producer">
                  <response-header-provider class="jetty-no-response-headers"/>
                  <status-provider class="http-configured-status">
                    <status>OK_200</status>
                  </status-provider>
                  <content-type-provider class="http-configured-content-type-provider">
                    <mime-type>application/json</mime-type>
                  </content-type-provider>
                  <send-payload>true</send-payload>
                </producer>
              </standalone-producer>
            </services>
          </service-collection>
        </standard-workflow>
        <pooling-workflow>
          <unique-id>DoLookup</unique-id>
          <send-events>false</send-events>
          <consumer class="jetty-message-consumer">
            <unique-id>/lookups/soiltype</unique-id>
            <destination class="configured-consume-destination">
              <configured-thread-name>SoiltypeLookup</configured-thread-name>
              <destination>/lookups/soiltype</destination>
            </destination>
            <parameter-handler class="jetty-http-parameters-as-metadata"/>
            <header-handler class="jetty-http-ignore-headers"/>
          </consumer>
          <service-collection class="service-list">
            <services>
              <trim-metadata-service>
                <metadata-key-regexp>^(lat|lon)$</metadata-key-regexp>
              </trim-metadata-service>
              <validate-metadata-service>
                <required-key>lat</required-key>
                <required-key>lon</required-key>
              </validate-metadata-service>
              <add-formatted-metadata-service>
                <unique-id>GenerateURL</unique-id>
                <format-string>${soiltypes.url}</format-string>
                <argument-metadata-key>lat</argument-metadata-key>
                <argument-metadata-key>lon</argument-metadata-key>
                <metadata-key>soilTypeLookupURL</metadata-key>
              </add-formatted-metadata-service>
              <add-formatted-metadata-service>
                <unique-id>GenerateCacheKey</unique-id>
                <format-string>lat=%1$s&amp;lon=%2$s</format-string>
                <argument-metadata-key>lat</argument-metadata-key>
                <argument-metadata-key>lon</argument-metadata-key>
                <metadata-key>soilTypeKey</metadata-key>
              </add-formatted-metadata-service>
              <branching-service-collection>
                <first-service-id>checkCache</first-service-id>
                <services>
                  <check-cache>
                    <unique-id>checkCache</unique-id>
                    <connection class="shared-connection">
                      <lookup-name>soil-type-cache</lookup-name>
                    </connection>
                    <cache-entry-evaluator>
                      <key-translator class="metadata-cache-value-translator">
                        <metadata-key>soilTypeKey</metadata-key>
                      </key-translator>
                    </cache-entry-evaluator>
                    <keys-not-found-service-id>GetSoilTypeFromRemote</keys-not-found-service-id>
                    <keys-found-service-id>GetSoilTypeFromCache</keys-found-service-id>
                  </check-cache>
                  <service-list>
                    <unique-id>GetSoilTypeFromRemote</unique-id>
                    <services>
                      <!-- Mark it as not from the cache -->
                      <add-metadata-service>
                        <metadata-element>
                          <key>data.from.cache</key>
                          <value>false</value>
                        </metadata-element>
                      </add-metadata-service>

                      <!-- Do the Call -->
                      <standalone-requestor>
                        <producer class="apache-http-producer">
                          <destination class="metadata-destination">
                            <key>soilTypeLookupURL</key>
                          </destination>
                          <method-provider class="http-configured-request-method">
                            <method>GET</method>
                          </method-provider>
                          <response-header-handler class="apache-http-response-headers-as-metadata">
                            <metadata-prefix>SoilGrids_</metadata-prefix>
                          </response-header-handler>
                          <ignore-server-response-code>true</ignore-server-response-code>
                        </producer>
                      </standalone-requestor>

                      <!-- Add to the cache -->
                      <add-to-cache>
                        <connection class="shared-connection">
                          <lookup-name>soil-type-cache</lookup-name>
                        </connection>
                        <cache-entry-evaluator>
                          <key-translator class="metadata-cache-value-translator">
                            <metadata-key>soilTypeKey</metadata-key>
                          </key-translator>
                          <value-translator class="string-payload-cache-translator"/>
                        </cache-entry-evaluator>
                      </add-to-cache>

                    </services>
                  </service-list>
                  <service-list>
                    <unique-id>GetSoilTypeFromCache</unique-id>
                    <services>
                      <!-- Add metadata that would be driven from remote request -->
                      <add-metadata-service>
                        <metadata-element>
                          <key>SoilGrids_Content-Type</key>
                          <value>application/json</value>
                        </metadata-element>
                        <metadata-element>
                          <key>adphttpresponse</key>
                          <value>200</value>
                        </metadata-element>
                        <metadata-element>
                          <key>data.from.cache</key>
                          <value>true</value>
                        </metadata-element>
                      </add-metadata-service>

                      <!-- Get it from the cache -->
                      <retrieve-from-cache>
                        <connection class="shared-connection">
                          <lookup-name>soil-type-cache</lookup-name>
                        </connection>
                        <cache-entry-evaluator>
                          <key-translator class="metadata-cache-value-translator">
                            <metadata-key>soilTypeKey</metadata-key>
                          </key-translator>
                          <value-translator class="string-payload-cache-translator"/>
                        </cache-entry-evaluator>
                      </retrieve-from-cache>
                    </services>
                  </service-list>
                </services>
              </branching-service-collection>
              <json-transform-service>
                <source-json class="string-payload-data-input-parameter"/>
                <target-json class="string-payload-data-output-parameter"/>
                <mapping-spec class="file-data-input-parameter">
                  <destination class="configured-produce-destination">
                    <destination>${adapter.soiltype.mapping.url}</destination>
                  </destination>
                </mapping-spec>
                <metadata-filter class="regex-metadata-filter"/>
              </json-transform-service>
              <metadata-key-to-upper-case>
                <keys-to-modify class="regex-metadata-filter">
                  <include-pattern>^SoilGrids.*$</include-pattern>
                </keys-to-modify>
              </metadata-key-to-upper-case>
              <standalone-producer>
                <unique-id>SendResponse</unique-id>
                <producer class="jetty-standard-response-producer">
                  <response-header-provider class="jetty-metadata-response-headers">
                    <filter class="regex-metadata-filter">
                      <include-pattern>Accept-Ranges</include-pattern>
                      <include-pattern>Cache-Control</include-pattern>
                      <include-pattern>Expires</include-pattern>
                      <include-pattern>Last-Modified</include-pattern>
                      <include-pattern>ETag</include-pattern>
                    </filter>
                  </response-header-provider>
                  <status-provider class="http-metadata-status">
                    <code-key>adphttpresponse</code-key>
                  </status-provider>
                  <content-type-provider class="http-metadata-content-type-provider">
                    <metadata-key>SOILGRIDS_CONTENT-TYPE</metadata-key>
                  </content-type-provider>
                  <send-payload>true</send-payload>
                </producer>
              </standalone-producer>
            </services>
          </service-collection>
        </pooling-workflow>
      </workflow-list>
    </channel>
  </channel-list>
  <message-error-digester class="standard-message-error-digester">
    <digest-max-size>100</digest-max-size>
    <unique-id>ErrorDigest</unique-id>
  </message-error-digester>
</adapter>